## 简单总结 ##

    https://juejin.im/post/5dcaebea518825571f5c4ab0#heading-5

### 缓存数据类型 ###

缓存是高并发场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用。

缓存类型分为：本地缓存，分布式缓存和多级缓存。

**本地缓存：**

本地缓存就是在进程的内存中进行缓存，比如 JVM 堆中，可以用 LRUMap(Least Recently Used MAP) 来实现，也可以使用Ehcache 这样的工具来实现。

本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。

**分布式缓存：**

分布式缓存可以很好的解决这个问题。

分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。

**多级缓存：**

为了平衡这个情况，实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据存放在分布式缓存中。

单靠单一的缓存方案往往很难以撑住很多高并发场景。

### 淘汰策略 ###

不管是本地缓存还是分布式缓存，为了保证较高性能，都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。

一般的剔除策略有 FIFO 淘汰最早的数据，LRU 剔除最近最近最少使用，和 LFU 剔除最近使用频率最低的数据几种策略。

- **noeviction：** 返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入命令，但 DEL 和几个例外）
- **allkeys-lru：** 尝试回收最少使用的键（LRU）,使得新添加的数据有空间存放。
- **volatile-lru：** 尝试回收最少使用的键 （LRU）,但仅限于在过期集合的键，使得新添加的数据有空间存放。
- **allkeys-random：** 回收随机的键 使得最新添加的数据有空间存放。
- **volatile-random：** 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
- **volatile-ttl：** 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。

如果没有 键满足回收的前提条件的话，策略 volatile-lru，volatile-random 以及 volatile-ttl 就和 noevction 差不多了。

    // TODO : 手写 LRU 算法


### Memcache ###

MC 特点：

- MC 处理请求时 使用多线程异步 IO 的方式，可以合理利用 CPU 多核优势，性能非常优秀；
- MC 功能简单，使用内存存储数据；
- MC 的内存结构以及钙化问题（`http://www.memcached.org/about`）
- MC 对缓存的数据设置失效期，过期的数据会被 清楚；
- 失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；
- 当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。

另外，使用 MC 有一些限制，这些限制在限制的互联网场景下很致命，成为大家选择 Redis,MongoDB的重要原因：

- key 不能超过250 个字节；
- value 不能超过 1M 字节；
- key 的最大失效时间是 30天；
- 只支持 K-V 结构，不提供持久化和主从同步功能。


### Redis ###

Redis 和 MC 比较

- 与MC 不同的是，Redis 采用单线程模式处理请求。这样做的原因有两个：一个是因为采用了非阻塞的异步事件处理机制；另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。
- Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL数据库。
- 相比 MC ，Redis还有个非常大的优势，就是除了 K-V 之外，还支持多种数据结构，例如：list, set, sorted set, hash 等。
- Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。

### 详解 Redis ###


