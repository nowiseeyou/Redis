## 简单总结 ##

    https://juejin.im/post/5dcaebea518825571f5c4ab0#heading-5

### 缓存数据类型 ###

缓存是高并发场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用。

缓存类型分为：本地缓存，分布式缓存和多级缓存。

**本地缓存：**

本地缓存就是在进程的内存中进行缓存，比如 JVM 堆中，可以用 LRUMap(Least Recently Used MAP) 来实现，也可以使用Ehcache 这样的工具来实现。

本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。

**分布式缓存：**

分布式缓存可以很好的解决这个问题。

分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。

**多级缓存：**

为了平衡这个情况，实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据存放在分布式缓存中。

单靠单一的缓存方案往往很难以撑住很多高并发场景。

### 淘汰策略 ###

不管是本地缓存还是分布式缓存，为了保证较高性能，都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。

一般的剔除策略有 FIFO 淘汰最早的数据，LRU 剔除最近最近最少使用，和 LFU 剔除最近使用频率最低的数据几种策略。

- **noeviction：** 返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入命令，但 DEL 和几个例外）
- **allkeys-lru：** 尝试回收最少使用的键（LRU）,使得新添加的数据有空间存放。
- **volatile-lru：** 尝试回收最少使用的键 （LRU）,但仅限于在过期集合的键，使得新添加的数据有空间存放。
- **allkeys-random：** 回收随机的键 使得最新添加的数据有空间存放。
- **volatile-random：** 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
- **volatile-ttl：** 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有空间存放。

如果没有 键满足回收的前提条件的话，策略 volatile-lru，volatile-random 以及 volatile-ttl 就和 noevction 差不多了。

    // TODO : 手写 LRU 算法


### Memcache ###

MC 特点：

- MC 处理请求时 使用多线程异步 IO 的方式，可以合理利用 CPU 多核优势，性能非常优秀；
- MC 功能简单，使用内存存储数据；
- MC 的内存结构以及钙化问题（`http://www.memcached.org/about`）
- MC 对缓存的数据设置失效期，过期的数据会被 清楚；
- 失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；
- 当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。

另外，使用 MC 有一些限制，这些限制在限制的互联网场景下很致命，成为大家选择 Redis,MongoDB的重要原因：

- key 不能超过250 个字节；
- value 不能超过 1M 字节；
- key 的最大失效时间是 30天；
- 只支持 K-V 结构，不提供持久化和主从同步功能。


### Redis ###

Redis 和 MC 比较

- 与MC 不同的是，Redis 采用单线程模式处理请求。这样做的原因有两个：一个是因为采用了非阻塞的异步事件处理机制；另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。
- Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL数据库。
- 相比 MC ，Redis还有个非常大的优势，就是除了 K-V 之外，还支持多种数据结构，例如：list, set, sorted set, hash 等。
- Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。

### 详解 Redis ###

#### 高级用法 ####

**Bitmap ：**

位图是支持 bit 位来存储信息的，可以用来实现 布隆过滤器（BloomFilter）;

**HyperLogLog ：**

供不精确的去重的计数功能，比较适合用来做大规模数据的去重统计，例如 UV;

**Geospatial ：**

可以用来保存地理位置，并做位置距离计算或者根据半径计算位置 等。

这三个其实也可以算作一种数据结构

**pub/sub ：**

功能是订阅发布功能，可以做简单的消息队列。

**Pipeline ：**

可以批量执行一组命令，一次性放回全部结果，可以**减少频繁**的应答请求。

**Lua ：**

Redis 支持提交  Lua 脚本来执行一系列的功能。（利用原子性 做秒杀）

**事务 ：**

最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时不会回滚，而是继续执行下去。

#### 高可用 ####

Redis 支持主从同步，提供 Cluster 集群部署模式，通过 Sentine |哨兵来监控 Redis主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof 到新主。

选主的策略：

- slave 的 priority 设置的越低，优先级越高；
- 同等情况下, slave 复制的数据越多优先级越高；
- 相同的条件下， runid 越小越容易被选中。

在 Redis 集群中，sentinel 也会进行过实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。

Redis Cluster 使用分片机制，在内部分为 16384 个slot 插槽，分布在所有的master 节点上，每个 master 节点负责一部分 slot。数据操作时 按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。


### 重点 ###


- 要知道 缓存的使用场景，不同类型缓存的使用方式，例如：


1  对 DB 热点数据进行缓存减少 DB 压力； 对依赖的服务进行缓存，提高并发性能；

2  单纯 K-V缓存场景可以使用 MC，而需要缓存 list，set 等特殊数据格式，可以使用 Redis;

3  需要缓存一个用户最近播放视频列表可以使用 Redis 的 list 来保存、需要计算排行榜数据时，可以使用 Redis 的 zset 结构来保存。



-  要了解 MC 和 Redis 常用命令，例如原子增减，对不同数据结构进行操作的命令等。
-  了解 MC 和 Redis 在内存中的存储结构。
-  了解 MC 和 Redis 的数据失效方法和剔除策略，比如主动触发的定期剔除和被动触发的延期剔除。
-  要了解 Redis 的持久化，主从同步与 Cluster 部署原理，比如 RDB 和 AOF的实现方式和区别。
-  要知道缓存穿透，击穿，雪崩分别的异同和解决方式。
-  秒杀的具体实现。