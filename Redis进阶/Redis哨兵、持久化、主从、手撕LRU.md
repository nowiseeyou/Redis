## Redis哨兵、持久化、主从、手撕LRU ##

    https://juejin.im/post/5dc3a9fbf265da4d3c072eab

**Redis** 采用的是基于内存的单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到 100000+ 的QPS(每秒的查询次数)。


- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的数据存在内存中，类似于 HashMap,HashMap 的优势就是查找和操作的时间复杂度都是 O（1）；
- 数据结构简单，对数据操作也很简单，Redis中的数据结构是专门进行设计的；
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程多或者多线程导致的切换而消耗CPU,不用去考虑各种锁的问题，不存在加锁释放锁的操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路 I/O 复用模型，非阻塞IO;
- 使用底层模型不同，他们之间的底层实现的方式及客户端之间的通信的应用协议不一样，Redis直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

## 持久化 ##

**Redis持久化**是Redis高可用中比较重要的一个环节，因为Redis数据在内存的特性，持久化必须得有，持久化的两支方式  ：

- RDB : RDB 持久化机制，是对Redis中的数据执行周期性持久化。
- AOF : AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql 中的 binlog。

两种方式都可以把 Redis 内存中的持久化到磁盘上，然后再讲这些数据备份到别的地方去，RDB 更适合做**冷备**，AOF 更适合做热备，比如我杭州的某电商公司有着两个数据，我备份一份到我杭州节点，在备份一个到上海的，就算发生无法避免的自然灾害，也不会两个地方一起挂吧，这灾备也就是异地容灾。

tip：两种机制全部开启的时候，Redis 在重启的时候回默认使用AOF去重新构建数据，因为AOF 的数据是比 RDB 更完整的。

### RDB / AOF 优缺点 ###

#### RDB ####

**优点：**

他会生成多个数据文件，每个数据数据文件分别都代表了某一时刻Redis里面的数据，这种方式，有没有觉得很适合做冷备，完整的数据运维设置定时任务，定时同步到远端服务器，比如阿里云的 云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。

RDB 对 Redis的性能影响非常小，是因为在同步数据的时候也只是fork 了一个子进程去做持久化的，而且他在数据恢复的时候 速度比 AOF 来的快。

**缺点：**

RDB 都是快照文件，都是默认五分钟 甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉，AOF 则最多丢失一秒的数据，数据完整性上 高下立判。

还有就是 RDB 在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒 甚至几秒，你公司在做秒杀的时候也刚好在这个时候 fork 了一个子进程去生成一个大快照。

#### AOF ####

**优点：**

RDB 五分钟一次生成快照，但AOF 是一秒一次去通过一个后台的线程 fsync 操作，那最多丢失这一秒的数据。

AOF 在对日志文件进行操作的时候是以 append-only 的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。

AOF 的日志是通过一个叫 **非常可读** 的方式记录的，这样的特性就很适合做 **灾难性数据** 误删除的紧急恢复了，比如公司实习生通过 flushall 清空了所有数据，只要这个时候后台重写还没发生，你马上拷贝一份 AOF 日志文件，把最后一条 flushall 命令删了就完事了。

**缺点：**

一样的数据，AOF文件比RDB 还要大。

AOF 开启后，Redis 支持写的 QPS 会比 RDB 支持写的要低，他不是每秒都要去异步刷新一次日志 fsync，当然即使这样性能还是很高，我记得 ElasticSearch 也是这样的，异步刷新缓存区的数据去持久化。（思考：为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的）

## 哨兵 ##


哨兵必须用三个实例去保证自己的健壮性，哨兵 + 主从并不能保证数据不丢失，但是可以保证机器的高可用。

哨兵组件的主要功能 ： 

- 集群监控 ： 负责监控 Redis master 和 slave 进程是否正常工作。
- 消息通知 ： 如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知管理员。
- 故障转移 ： 如果 master node 挂掉了， 会自动转移到 slave node 上。
- 配置中心 ： 如果故障转移发生了，通知 client 客户端新的 master 地址。 


## Redis 主从同步 ##

单机 QPS 是有上限的，而且 Redis的特性就是必须支撑读高并发，你让 master机器去写，数据同步给别的 slave 机器，他们都拿去读，分发掉大量的请求是不是会好很多，而且扩容的时候还可以轻松实现水平扩容。

### 如何同步 ###

你启动一台 slave 的时候，他会发送一个 psync 命令给 master ,如果是这个 slave 第一次连接到 master， 他会触发一个 全量复制。 master 就会启动一个线程，生成 RDB 快照，还会把新的写请求缓存在内存中， RDB 文件生成后， master 会将这个 RDB  发送给 slave的，slave 拿到之后做的第一件事就是写入本地的磁盘，然后加载进内存，然后 master 会把内存里面缓存的哪些新命名都发给  slave 。

**注意：** RDB 快照数据生成的时候，缓存区也必须同时开始 接收新的请求。

## LRU 内存淘汰机制 ##

Redis 的过期策略，定期删除 + 惰性删除 ；

定期删除好理解，默认 100ms就随机抽一些 设置了过期时间的key, 去检查是否过期，过期了就删除。

### 为何不扫描全部设置了过期时间的 KEY ###

假如 Redis 里面的所有的 key 都有过期时间，都扫描一遍？太恐怖了，而且我们线上基本也都会设置一定的过期时间。 全扫描 跟你去数据库 不带 where 条件 不走索引全表扫描一样，100ms一次，Redis累都累死了。
