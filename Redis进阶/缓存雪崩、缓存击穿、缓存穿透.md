## 缓存雪崩 ##

### 概念 ###

大量的 key 设置了相同的过期时间，导致缓存在同一时刻全部失效，造成瞬时DB请求量过大，压力骤增，引起雪崩。

### 解决方法 ###

可以给缓存设置过期时间加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。


## 缓存击穿 ##

### 概念 ###

一个存在的 key ,在缓存过期的那一刻，同时有大量的请求，这些请求都会击穿到 DB,造成瞬时 DB 请求量过大，压力骤增。

### 解决方法 ###

1. 在访问 key 之前，采用 **SETNX(set if not exists)** 来设置另一个短期 key 来锁住当前 key 的访问，访问结束再删除该短期 key 。
2. 设置热点数据永远不过期。或者加上互斥锁。

## 缓存穿透 ##

### 概念 ###

访问一个不存在的 key, 缓存不起作用，请求会穿透到DB ,流量大时 DB 会挂掉。

### 解决方法 ###

1. 采用 **布隆过滤器**，使用一个足够大的 bitmap ,用于存储可能访问的 key,不存在的 key 直接被过滤；
2. 访问 key 未在 DB 查询到值，也将空值写进缓存，但可以设置较短的过期时间。


## 总结 ##

- 事前： Redis 高可用，主从+哨兵，Redis cluster, 避免全盘崩溃。
- 事中： 本地 ehcache 缓存 + Hystrix 限流 + 降级 ， 避免 **MYSQL** 被打死。
- 事后： Redis 持久化 RDB + AOF , 一旦重启，自动从磁盘上加载数据， 快速回复 缓存数据。 

### 好处 ###

数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。只要数据库不是，就是说，对用户来说，， 3/5 的请求都是可以被处理的。 只要有 3 / 5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。


## Redis-避免缓存穿透的利器之BloomFilter ##

