## Redis双写一致性、并发竞争、线程模型 ##

### Redis五大数据结构（string、hash、list、set,sorted set）和使用场景 ###

#### 字符串（String） ####

最简单的类型，就是普通的 set  和 get，做简单的 KV缓存。

**String** 的实际应用场景比较广泛的有：

- 缓存功能： string 字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用 Redis 作为缓存，配合其他数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。
- 计数器： 许多系统都会使用 Redis 作为系统的实时计数器，可以快速实现计数和查询功能。 而且最终的数据结果可以按照特定的时间落地到数据的库或者其他存储介质当中进行永久保存。
- **共享用户Session ： ** 用户重新刷新一次界面，可能需要访问一下数据库重新登录，或者访问页面缓存 Cookie，但是可以利用 Redis 将用户的 Session 集中管理，在这种模式只需要保证 Redis 的高可用，每次用户 Session 的更新和获取都可以快速完成。大大提高效率。

#### 哈希（Hash） ####

这个类似 Map 的一种结构，这个 一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套 其他的对象）给缓存在  Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段

但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象里面可能就包含了很多属性，其中也有对象。我们自己使用的场景用的不是那么多。

#### 链表（List） ####

**List** 本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。


- **消息队列： ** Redis 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计，比如：数据的生产者可以通过 Lpush 命令从左边插入数据，多个数据消费者，可以使用BRpop 命令阻塞的“抢”列表尾部信息。
- 文章列表或者数据分页的展示的应用。

比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 Redis的列表，列表补单有序同时还支持按照范围内获取元素，可以完美的解决分页查询功能。大大提高查询效率。

#### 无序集合（Set） ####

直接基于 SET 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 JVM 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上，得基于 Redis 进行全局的 Set 去重。

#### 有序集合 (Sorted Set) ####

Sorted set 是排序的 Set， 去重但可以排序，写进去的时候给一个分数，自动根据分数排序。

有序集合的使用场景 和集合类似，但是 set 集合不会自动排序的，而 Sort set 可以利用分数进行成员间的排序，而且是插入时就排好。所以当你需要一个有序且不重复的集合列表时，可以选择 Sort Set 数据结构作为选择方案。

- 排行榜：有序集合经典实用场景。例如视频网站需要对用户上传视频做排行榜，榜单维护可能是很多方面：按照时间，按照播放量，按照获得赞数等。
- 用Sorted Set来做带权重的队列，比如普通消息的 score 为1， 重要的消息 score 为2，然后工作线程可以选择 按 score 的倒叙来获取工作任务。让重要的任务优先执行。


### 并发竞争 ###

系统A 、B、C三个系统，分别去操作 Redis 的同一个 Key，本来顺序是1,2,3是正常的，但是因为系统A 网络突然抖动一下，B,C在她前面操作了 Redis，这样数据不就错了吗？


某个时刻，多个系统实例都去更新某个 key。 可以基于 Zookeeper 实现分布式锁。每个系统通过 Zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 Key，别人都不允许读写、

你要写入 缓存的数据，都是从Mysql 里查出来的，都得写入Mysql中，写入Mysql 中的时候必须保存一个时间戳，从 mysql查出来的时候，时间戳也查出来。

每次要写之前，先判断一下当前这个 Value 的时间戳是否比缓存的 Value 的时间戳要新，如果是的话，那么怎么写，否则，就不能用旧的数据覆盖新的数据。




