	https://juejin.im/post/5d8882c8f265da03951a325e

## string ##

 **string** 是redis 最基本的类型，可以理解成与 Memcached 一模一样的类型，一个 key对应一个 value。 value其实不仅是 String，也可以是数字，string 类型是二进制安全的。意思是Redis的 string 可以包含任何数据，比如 jpg 图片或序列化的对象。 string 类型是 Redis最基本的数据类型，string类型的值最大能存储 512MB。

#### 常用命令 ####

**get  set  incr  decr  mget** 等

#### 应用场景 ####

**String** 是最常用的一种数据类型，普通的 key/value 存储都可以归为此类，既可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化，操作日志及 Replication 等功能。除了提供与 Memcached 一样的 **get set incr decr** 等操作外，Redis还提供了下面一些操作：

- 获取字符串长度
- 往字符串 append 内容
- 设置和获取字符串的某一段内容
- 设置及获取字符串的某一位（bit）
- 批量设置一系列字符串的内容

#### 使用场景 ####

常规 key-value 缓存应用，常规计数：微博数，粉丝数。
**实现方式：**  String 在 Redis 内部存储默认就是一个字符串，被 redisObject 所引用，当遇到 **incr,decr** 等操作时会转成数值型进行计算，此时 redisObject的 encoding 字段为 int。

**注意：** 一个键最大能存储 512MB


## Hash ##

**Redis Hash** 存储用户信息，Key 作为用户 uid ，value 是一个 Map ，这个 Map 的 Key 是成员的属性名，value 是属性值，这样对数据的修改和存取都可以直接通过内部 Map 的 key ( Redis 里称内部 Map 的 key 为 field)，也就是通过 key(uid) + field(属性标签) 就可以直接操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。

#### 常用命令 ####

**hset hget hmset hmget**

#### 使用场景 ####

存储部分变更数据，如用户信息等。

#### 实现方式 ####

**Redis Hash** 对应 Value 内部实际就是一个 HashMap ， 实际这里会有两种不同实现，这个Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 value redisObject 的 encoding 为zipmap，当成员数量增大时会自动转成真正的 HashMap ， 此时 encoding 为 ht。


**注意：** Redis 提供了接口（hgetall） 可以直接取到全部的接口数据，但是如果内部 Map 的成员很多，那么涉及到了遍历整个内部 Map 的操作，由于 Redis 单线程模型的缘故，这个遍历操作可能会比较耗时，而另其他客户端的请求完全不响应，这点格外需要注意。 每个 hash 可以存储 2^32 - 1 键值对（40多亿）


## List ##

list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表头部（左边）或者 尾部（右边）。

#### 常用命令 ####

- lpush - 添加左边元素
- rpush - 添加右边元素
- lpop - 移除左边第一个元素
- rpop - 移除右边第一个元素
- lrange - 获取列表片段 ( LRANGE key start stop)

#### 应用场景 ####

**Redis list** 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现。

**List** 就是链表，使用 List 结构，我们可以轻松地实现最新消息排行等功能，List 的另一个应用就是**消息队列** ，可以利用 List 的PUSH 操作，将任务存在 List中，然后工作线程再用 POP 操作将任务取出进行执行。Redis 还提供了操作 List 某一段的 api，你可以直接查询，删除 List 中某一段的元素。

#### 实现方式 ####

**Redis List** 的实现为一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

**Redis List** 是每个子元素都是 String 类型的双向链表，可以通过 push 和 pop 操作从列表的头部或者尾部添加或者删除元素，这样 list 既可以作为栈，也可以作为队列。获取越接近两端的元素速度越快，但通过索引访问时比较慢。

#### 使用场景 ####

**消息队列系统**：使用 List 可以构建队列系统，使用 sorted set 甚至可以构建有优先级的队列系统。比如将 Redis 用作日志收集器，实际上还是一个队列，多个端点将日志信息写入 Redis，然后一个worker 统一将所有日志写到磁盘。

取最新 N 个数据的操作： 记录前 N 个最新登录的用户 ID 列表，超出的范围可以从数据库中获得。


    # 把当前登录人添加到链表里
	ret = r.lpush("login:last_login_times", uid) //保持链表只有N位
	ret = redis.ltrim("login:last_login_times", 0, N-1) //获得前N个最新

	# 登陆的用户Id列表
	last_login_list = r.lrange("login:last_login_times", 0, N-1)

比如微博 : 在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过 5000 个ID ，因此我们的获取ID函数会一直询问 Redis 。只有在 start/count 参数超出了这个范围的时候，才需要去访问数据库。我们的系统不会像传统方式那样， “刷新” 缓存，Redis 实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库） 只有在用户需要获取 “很远” 的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。

**注意：** 列表最多可存储 2^32 -1 元素（4294967295，每个列表最多可存储40多亿）

## SET ##

**set** 是 string 类型的无序集合。集合是通过 **hashtable** 实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等，set 中的元素没有顺序的。所以添加，删除，查找的复杂度都是 O(1)。

**sadd 命令：** 添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0 ，如果 key 对应的 set 不存在则返回错误。

#### 常用命令 ####

- sadd — 向集合添加一个或多个成员
- spop — 移除并返回集合中的一个随机元素
- smembers — 返回集合所有成员
- sunion — 返回所有给定集合的并集

#### 应用场景 ####

**Redis set** 对外提供的功能与list类似是一个列表的功能，特殊之处在于set 是可以自动排序重的，当你需要储存一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且set提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是list所不能提供的。

**Set** 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。

**案例：** 在微博中，可以将一个用户所有的关注存在一个集合中，将其粉丝所有的粉丝存在一个集合。 Redis 还为集合提供了求交集，并集，差集等操作，可以非常方便的实现如共同关注，共同喜好，二度好友等功能，对上面的所有集合的操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。

#### 实现方式 ####

**SET** 内部实现是一个 value 永远为 null 的 HashMap，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。

**使用场景**： 

- 交集，并集，差集
- 获取某段时间所有数据去重值，这个使用 Redis 的 set 数据结构最合适了，只需要不断的将数据往set 中扔就行了，SET 意为集合，所以会自动排重

	sadd key member

**注意：** 根据集合内元素的唯一性，第二次插入的元素将被忽略。集合中最大的成员数为 2^32 -1 (4294967295，每个集合可存储40多亿成员)。



## zset ##

**zset** 和 set 一样也是 string 类型元素的集合，且不允许重复的成员。 

#### 常用命令 ####

- zadd — 向有序的 集合添加一个或多个成员，或者更新已存在的成员分数
- zrange — 通过索引区间返回有序集合指定区间的成员
- zrem — 移除有序集合中指定成员的索引
- zcard — 返回有序集合的成员数

#### 使用场景 ####

**Redis sorted set** 的使用场景与 set 类似，区别是 set 不是自动有序的，而sorted set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择 sorted set 数据结构。比如 twitter 的 publictimeline 可以以发布时间作为 score 来存储，这样获取时就是自动按时间排好序的，和 set 相比， **Sorted Set 关联了一个 double 类型权重参数 score**,使得集合中的元素能够按 score 进行有序排列，redis 正是通过分数来为集合中的成员进行从小到大的排序。 zset 的成员是唯一的，但分数 （score）却可以重复。

比如：一个存储全班同学成绩的 Sorted Set，其集合 value可以是同学的学号，而score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行天然排序。另外还可以用 sorted set 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要任务先执行。

#### 实现方式 ####

**Redis Sorted Set** 的内部使用 HashMap 和 跳跃表（SkipList）来保证数据的存储和有序，HashMap里放的是成员到 score 的映射，而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存放的 score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。



# 各个数据类型应用场景 #


## string(字符串) ##

#### 简介 ####

二进制安全 

#### 特性 ####

可以包含任何数据，比如jpg 图片或者序列化对象，一个键最大能存储 512M。


## Hash(字典) ##

#### 简介 ####

键值对集合，即编程语言中的 Map 类型

#### 特性 ####

适合存储对象，并且可以像数据库 update 一个属性一样只修改某一项属性值（Memcached 中需要取出整个字符串反序列化成对象修改完再序列化存回去）

#### 场景 ####

存储，读取，修改用户属性



## List(列表) ##

#### 简介 ####

链表（双向链表）

#### 特性 ####

增删快，提供了操作某一段元素的 API

#### 场景 ####

- 最新消息排行等功能（比如朋友圈的时间线）
- 消息队列

## Set(集合) ##

#### 简介 ####

哈希表实现，元素不重复

#### 特性 ####

- 添加，删除，查找的复杂度都是 O(1) 
- 为集合提供了求交集，并集，差集等操作

#### 场景 ####

- 共同好友
- 利用唯一性，统计访问网站的独立 ip 
- 好友推荐时，根据tag求交集，大于某个 阈值 就可以推荐

## Sorted Set(有序集合) ##

#### 简介 ####

将 set 中的元素增加一个权重参数 score ，元素按 score 有序排列

#### 特性 ####

数据插入集合时，已经进行天然排序

#### 场景 ####

- 排行榜
- 带权重的消息队列


## Redis 实际应用场景 ##
**Redis**在很多方面与其他数据库解决方案不同：

- 它使用内存提供主存储支持，而仅使用硬盘做持久性的存储；  他的数据模型非常独特，用的单线程，另一个区别在于，你可以在开发环境中使用 Redis的功能，但却不需要转到 Redis。转向redis 当然也是可取的，许多开发者从一开始就把 Redis 作为首选数据库； 但设想如果你开发环境已经搭建好，应用已经在上面开始运行了，那么更换数据库框架显然不那么容易。另外在一些需要大容量数据集的应用，Redis并不适合，因为它的数据集不会超过系统可用的内存。 所以如果你有大数据应用，而且主要是读取访问模式，那么 Redis 并不是正确的选择。

Redis 可以很简单的融入 你的系统中，解决很多难以处理的问题，比如 现有数据库处理起来感觉缓慢的任务，都可以通过 Redis 进行优化，或者为应用创建些新的功能。 


#### 显示最新的项目列表 ####

下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。

	SELECT * FROM foo WHERE ... ORDER BY time DESC LIMIT 10

在微博应用中，“列出最新回复” 之类的查询非常普遍，这通常会带来可扩展性问题。因为项目本来就是按这个顺序创建的，但要输出这个顺序却不得不进行排序操作。

类似的问题就可以用 Redis 来解决。比如说，我们的一个微博应用想要列出用户贴出的最新 20 条评论。在最新的评论边上我们有一个 "显示全部" 的链接，点击后就可以获得更多评论。

我们假设数据库中的每条评论都有一个唯一的递增的 ID 字段。 我们可以使用分页来制作主页和评论页，使用 Redis模板，每次新评论发表时，我们会将它的 ID 添加到一个 Redis 列表 ：

	# LPUSH key value1 [value2]
	LPUSH latestComments <ID>

我们将列表裁剪为指定长度，因此 Redis 只需要保存最新的 5000 条评论 ：

	# LTRIM key start stop
	LTRIM latestComments 0 5000

每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成

	function getLatestComments($start = 0,$num = 5000){
		$redis = new Redis();
		$id_list = $redis->Lrange("latestComments", $start, $start + $num -1 );

		if ($id_list < $num) {
			$id_list = SQL_DB("SELECT `id` FROM table WHERE ... ORDER BY time LIMIT ...");
		}

		return $id_list;
	}

	
在Redis 中 我们的最新ID 使用常驻缓存，这是一直更新的。但是我们做了限制  不超过 5000 个ID，因此我们的获取 ID 函数会一直访问 Redis 。 只有在 start/count 参数超出了 这个范围的时候，才需要去访问数据库。我们的系统不会像传统方式那样 “刷新缓存”， Redis 实例中的的信息永远一致的。SQL 数据库 （或硬盘上的其他类型数据库） 只是在用户需要获取 “很远” 的数据时才会被触发，而主页或第一个评论页，是不会麻烦到硬盘上的数据库了。

#### 删除 过滤 ####


